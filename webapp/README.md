# A Gridsome Vue.js project

This is a template for a Strapi-cms powered Vue.js website.

## Usage

1. `npm run dev` to start development server
2. `npm run prod` to pre-build production site and run local prod server.

The production-ready site is deployed to the `dist` folder,
the contents of which can be copied to your webhost as a static-served website.

## Hot reload

Changes in the code, during development, cause an automatic (hot) reload of the webapp. Changes made in content in the Strapi CMS require a manual reload of the corresponding webpage. A webapp server restart is required when new assets are added in the CMS.

## Static versus managed assets

Per Gridsome recommendations:

- Static assets like the favicon icons should be stored in the `static` folder.
- Managed assests like images that are referenced in the code through the `<g-image>` tag should be stored in the `src\assets` folder.

Note: confusingly, Gridsome will copy everything (including subfolder structures) inside the `static` folder directly to the `dist` distribution folder, while everything in `src\assets` is transformed and copied (excluding subfolder structures) into an `assets\static` subfolder of `dist`. Thus the folder named `static` in the distribution folder does not relate to the folder named `static` in the sources folder.

HOWEVER:

1. Gridsome uses an (in my view) anti-pattern in that all (dynamically accesed - i.e. the file name is not hard-coded in the webapp source files) image files in the `src\assets` folder get a base64 URI encoded blurred version, and those data strings are embedded in the `app.js` file.
    - It is essential to keep this `app.js` file as small as possible since its size will to a large extent determine initial load time of the website. A photo gallery for instance will add about 10kB per photo to the `app.js` size.
2. The Gridsome build processes all `<g-image>` images on each build attempt to not only create the blurred version but also to generate derived smaller responsive image files.
    - This would be much more efficient to do in a one-time pre-build step.

THEREFOR:

1. Media files from the CMS are stored in the `static` folder instead of in the `src\assets` folder.
2. Smaller-size images generated by Strapi CMS are used with a custom responsive image component instead of `<g-image>` and the Gridsome build process.

## Environment variables

In the project's root folder (`webapp`), create files `.env.development`and `.env.production` to store environment variables.

  E.g. for the Strapi CMS URL in development add the line:
  `CMS_URL=http://localhost:1337`
  which is accessed in `gridsome.config.js` as `process.env.CMS_URL`.

See `sample.env.development` and use that to creat your own `.env.development`and `.env.production` files.

(NOTE: Variables that should be available in the browser *must* be prefixed with `GRIDSOME_`. Variables without that prefix are available to the Gridsome server only; for security reasons.)

## source-graphql vs source-strapi

Gridsome (0.7.22) has two plugins that can be used to load data from Strapi CMS: `@gridsome/source-graphql` (0.1.0) and `@gridsome/source-strapi` (0.2.0). Neither is perfect. Both require workarounds. Here are the pros and cons:

### @gridsome/source-graphql

pro:

- a generic plugin that pulls in Strapi's graphql schema as-is. What's present within Gridsome is the same (aside from a namespace) as what's present in Strapi; including the powerfull Dynamic Zone conditional structures.
- any graphql queries that were written/tested in Strapi's graphql explorer can be copied to UI components (with a minor change to take the namespace into account). This includes conditional logic to handle Strapi's Dynamic Zones.

con:

- Gridsome's pagination support doesn't work, since that expects a specific graphql schema structure using `nodes` and `egdes`.

### @gridsome/source-strapi

pro:

- Gridsome's build-in pagination support works.

con:

- the plugin places Strapi data in a new schema structure, using `nodes` and `egdes`.
- the plugin does not support Strapi's Dynamic Zones. Instead it collapses the possible choices into one, and the others are absent. A UI component can only query one possible choice.

### Choice

The choice between the two plugins currently is the choice between adding a custom pagination implmentation to the UI, or adding a solution to Strapi to integrate the possible choices of Dynamic Zones into a fixed schema structure.

Since this template project is aimed at small to medium scale personal websites, with a manageable amount of data, I have opted to build a custom pagination and use `source-graphql`.
